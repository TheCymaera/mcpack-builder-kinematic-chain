/**
 * A IndexedDB-based Map
 */
export class IDBMap {
    database;
    storeName;
    constructor(database, storeName = "default") {
        this.database = database;
        this.storeName = storeName;
    }
    static async create(options) {
        const storeName = options.storeName ?? "IDBMap";
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(options.name);
            request.onsuccess = () => resolve(new IDBMap(request.result, storeName));
            request.onerror = () => reject(new IDBMap.ConnectionError(request.error.message));
            request.onupgradeneeded = () => {
                request.result.createObjectStore(storeName, { keyPath: "key" });
            };
        });
    }
    static async delete(name) {
        return new Promise((resolve, reject) => {
            const request = indexedDB.deleteDatabase(name);
            request.onsuccess = () => resolve();
            request.onerror = () => reject(new IDBMap.ConnectionError(request.error.message));
        });
    }
    async get(key) {
        const store = this.#getStore("readonly");
        const response = await this.#processRequest(store.get(key));
        return response?.value;
    }
    async set(key, value) {
        const store = this.#getStore("readwrite");
        await this.#processRequest(store.put({ key: key, value: value }));
    }
    async delete(key) {
        const store = this.#getStore("readwrite");
        return this.#processRequest(store.delete(key));
    }
    async clear() {
        const store = this.#getStore("readwrite");
        return this.#processRequest(store.clear());
    }
    async *entries() {
        const store = this.#getStore("readonly");
        const cursor = store.openCursor();
        while (true) {
            await new Promise(resolve => cursor.onsuccess = resolve);
            if (!cursor.result)
                return;
            const entry = cursor.result.value;
            yield [entry.key, entry.value];
            cursor.result.continue();
        }
    }
    #getStore(mode) {
        const transaction = this.database.transaction(this.storeName, mode);
        return transaction.objectStore(this.storeName);
    }
    async #processRequest(request) {
        return new Promise((resolve, reject) => {
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(new IDBMap.RequestError(request.error.toString()));
        });
    }
}
(function (IDBMap) {
    class ConnectionError extends Error {
        constructor(reason) { super("IDBMap - Connection error:\n" + reason); }
    }
    IDBMap.ConnectionError = ConnectionError;
    class RequestError extends Error {
        constructor(reason) { super("IDBMap - Request error:\n" + reason); }
    }
    IDBMap.RequestError = RequestError;
})(IDBMap || (IDBMap = {}));
//# sourceMappingURL=IDBMap.js.map