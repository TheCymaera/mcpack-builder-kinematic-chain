export class URI {
    scheme;
    authority;
    pathname;
    constructor(scheme = "", authority = "", pathname = "/") {
        this.scheme = scheme;
        this.authority = authority;
        this.pathname = pathname;
    }
    static fromString(string) {
        try {
            return new URI().setString(string);
        }
        catch (e) {
            return undefined;
        }
    }
    clone() {
        return (new URI).set(this);
    }
    isFile() {
        return !this.pathname.endsWith("/");
    }
    pathSegments() {
        return this.pathname.slice().split("/").filter(i => i);
    }
    directorySegments() {
        const segments = this.pathSegments();
        if (this.isFile())
            segments.pop();
        return segments;
    }
    filename() {
        if (!this.isFile())
            return "";
        const segments = this.pathSegments();
        return segments.pop() ?? "";
    }
    slug() {
        return this.pathSegments().pop() ?? this.authority;
    }
    appendString(path) {
        URI._setFromURL(this, new URL(path, this.toString()));
        return this;
    }
    setString(uriString) {
        URI._setFromURL(this, new URL(uriString));
        return this;
    }
    set(uri) {
        this.scheme = uri.scheme;
        this.authority = uri.authority;
        this.pathname = uri.pathname;
        return this;
    }
    isOrigin() {
        return this.pathname === "/";
    }
    hasSameOrigin(uri) {
        return this.scheme === uri.scheme && this.authority === uri.authority;
    }
    relativePathOf(uri) {
        if (!this.hasSameOrigin(uri))
            return uri.toString();
        const base = this.directorySegments();
        const rel = this.directorySegments();
        const contained = (array1, array2) => {
            for (let i = 0, l = array1.length; i < l; i++) {
                if (array1[i] !== array2[i])
                    return false;
            }
            return true;
        };
        let out = "";
        while (!contained(base, rel)) {
            out += "../";
            base.pop();
        }
        out += uri.filename();
        return out;
    }
    toString(encode = true) {
        const scheme = `${this.scheme}:`;
        const authority = this.authority ? `//${this.authority}` : "";
        const pathname = this.pathname;
        const uri = scheme + authority + pathname;
        return encode ? encodeURI(decodeURI(uri)) : uri;
    }
    setPathSegments(directories, file) {
        this.pathname = "/" + directories.join("/") + (file ? "/" + file : "");
        return this;
    }
    ascend(levels) {
        const segments = this.directorySegments();
        segments.length -= levels;
        return this.setPathSegments(segments);
    }
    descend(directories, file) {
        return this.setPathSegments([...this.directorySegments(), ...directories], file);
    }
    asFile() {
        if (this.pathname.endsWith("/"))
            this.pathname = this.pathname.slice(0, -1);
        return this;
    }
    asDirectory() {
        if (!this.pathname.endsWith("/"))
            this.pathname += "/";
        return this;
    }
    static _setFromURL(self, url) {
        self.scheme = url.protocol.slice(0, -1);
        self.authority = url.host;
        if (url.pathname.startsWith("//")) {
            const pathIndex = url.pathname.indexOf("/", 3);
            const pathIndexCapped = pathIndex === -1 ? url.pathname.length : pathIndex;
            self.authority = url.pathname.slice(2, pathIndexCapped);
            self.pathname = url.pathname.slice(pathIndexCapped);
        }
        else {
            self.pathname = url.pathname;
        }
    }
}
//# sourceMappingURL=URI.js.map