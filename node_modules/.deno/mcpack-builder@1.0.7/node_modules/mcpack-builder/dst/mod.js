let log = console;
export function setLogger(logger) {
    log = logger;
}
export class Namespace {
    namespace;
    constructor(namespace) {
        this.namespace = namespace;
    }
    id(id) {
        return new NamespacedID(this.namespace, id);
    }
    static validate(namespace) {
        const INVALID_NAMESPACE = 'Namespaces must only contain lowercase letters, numbers, dashes, and underscores';
        if (!/^[a-z0-9_-]+$/.test(namespace)) {
            return [INVALID_NAMESPACE];
        }
        return [];
    }
}
export class NamespacedID {
    namespace;
    id;
    constructor(namespace, id) {
        this.namespace = namespace;
        this.id = id;
        const errors = NamespacedID.validate(this.build());
        if (errors.length > 0) {
            log.warn(`Invalid namespaced ID: ${this.build()}`);
            for (const error of errors) {
                log.warn("  " + error);
            }
        }
    }
    childID(id) {
        return new NamespacedID(this.namespace, `${this.id}/${id}`);
    }
    build() {
        return `${this.namespace}:${this.id}`;
    }
    toFunction() {
        return new FunctionReference(this);
    }
    static fromString(namespacedId) {
        const [namespace, id] = namespacedId.split(':');
        return new NamespacedID(namespace ?? "", id ?? "");
    }
    static validate(namespacedId) {
        const [namespace, id, ...rest] = namespacedId.split(':');
        if (!namespace || !id || rest.length > 0) {
            return [`Namespaced ID must be in the format "namespace:id"`];
        }
        const errors = [];
        errors.push(...Namespace.validate(namespace));
        if (!/^[a-z0-9_\-/]+$/.test(id)) {
            errors.push(`Ids must only contain lowercase letters, numbers, underscores, dashes, and forward-slashes`);
        }
        return errors;
    }
}
export class Duration {
    value;
    unit;
    constructor(value, unit) {
        this.value = value;
        this.unit = unit;
    }
    build() {
        return `${this.value}${this.unit}`;
    }
    multiply(factor) {
        return new Duration(this.value * factor, this.unit);
    }
    toTicks() {
        switch (this.unit) {
            case "t":
                return this.value;
            case "s":
                return this.value * 20;
            case "d":
                return this.value * 24000;
        }
        throw new Error(`Unknown unit ${this.unit}`);
    }
    add(other) {
        if (this.unit !== other.unit) {
            throw new Error(`Cannot add durations with different units: ${this.unit} and ${other.unit}`);
        }
        return new Duration(this.value + other.value, this.unit);
    }
    static ticks(value) {
        return new Duration(value, "t");
    }
    static seconds(value) {
        return new Duration(value, "s");
    }
    static days(value) {
        return new Duration(value, "d");
    }
}
export var ScheduleMode;
(function (ScheduleMode) {
    ScheduleMode["Append"] = "append";
    ScheduleMode["Replace"] = "replace";
})(ScheduleMode || (ScheduleMode = {}));
export class FunctionReference {
    namespacedId;
    constructor(namespacedId) {
        this.namespacedId = namespacedId;
    }
    run() {
        return new CustomCommand(`function ${this.#selector()}`);
    }
    schedule(delay, mode = ScheduleMode.Replace) {
        return new CustomCommand(`schedule function ${this.#selector()} ${delay.build()} ${mode}`);
    }
    scheduleClear() {
        return new CustomCommand(`schedule clear ${this.#selector()}`);
    }
    #selector() {
        return this.namespacedId.build();
    }
}
export class TagReference {
    namespacedId;
    constructor(namespacedId) {
        this.namespacedId = namespacedId;
    }
    build() {
        return "#" + this.namespacedId.build();
    }
}
export class CustomCommand {
    command;
    constructor(command) {
        this.command = command;
    }
    buildCommand() {
        if (this.command.startsWith('/')) {
            log.warn(`Command "${this.command}" starts with a slash. This is invalid syntax in datapack functions.`);
        }
        return this.command;
    }
}
export class ScoreAllocator {
    scoreboard;
    prefix;
    constantPrefix;
    initConstants = [];
    constants = new Set();
    constructor(config) {
        this.scoreboard = config.scoreboard;
        this.prefix = config.prefix ?? "A_";
        this.constantPrefix = config.constantPrefix ?? "C_";
    }
    score() {
        let i = 0;
        let name;
        do {
            name = `${this.prefix}${i}`;
            i++;
        } while (this.#usedNames.has(name));
        this.#usedNames.add(name);
        const score = this.scoreboard.custom(name);
        return score;
    }
    constant(value) {
        const name = `${this.constantPrefix}${value}`;
        const score = this.scoreboard.custom(name);
        if (!this.constants.has(value)) {
            this.initConstants.push(score.assignConstant(value));
        }
        return score;
    }
    #usedNames = new Set();
}
export class Comment {
    comment;
    constructor(comment) {
        this.comment = comment;
    }
    buildCommand() {
        return `# ${this.comment}`;
    }
}
export class Scoreboard {
    objective;
    criteria;
    displayName;
    constructor(options) {
        this.objective = options.objective;
        this.criteria = options.criteria ?? 'dummy';
        this.displayName = options.displayName;
        const error = Scoreboard.verifyObjective(this.objective);
        if (error)
            log.warn(error);
    }
    create() {
        if (this.displayName === undefined) {
            return new CustomCommand(`scoreboard objectives add ${this.objective} ${this.criteria}`);
        }
        return new CustomCommand(`scoreboard objectives add ${this.objective} ${this.criteria} ${JSON.stringify(this.displayName)}`);
    }
    remove() {
        return new CustomCommand(`scoreboard objectives remove ${this.objective}`);
    }
    entity(target) {
        return new ScoreReference(this.objective, target);
    }
    custom(player) {
        return new ScoreReference(this.objective, new CustomSelector("", player));
    }
    static verifyObjective(objective) {
        if (objective.length > 16) {
            return 'Objective name must be 16 characters or less';
        }
        if (!/^[a-zA-Z0-9_]+$/.test(objective)) {
            return 'Objective name must only contain letters, numbers, and underscores';
        }
        return undefined;
    }
}
export class EntitySelector {
    selectorType = 'entity';
    constructor(variable) {
        this.#variable = variable;
    }
    buildSelector() {
        if (this.#arguments.length === 0)
            return this.#variable;
        return this.#variable + "[" + this.#arguments.join(',') + "]";
    }
    limit(count) {
        this.#arguments.push(`limit=${count}`);
        return this;
    }
    hasScoreboardTag(tag) {
        this.#arguments.push(`tag=${tag}`);
        return this;
    }
    noScoreboardTag(tag) {
        this.#arguments.push(`tag=!${tag}`);
        return this;
    }
    sortNearest() {
        this.#arguments.push('sort=nearest');
        return this;
    }
    sortFurthest() {
        this.#arguments.push('sort=furthest');
        return this;
    }
    sortRandom() {
        this.#arguments.push('sort=random');
        return this;
    }
    sortArbitrary() {
        this.#arguments.push('sort=arbitrary');
        return this;
    }
    static self() {
        return new EntitySelector('@s');
    }
    static nearestPlayer() {
        return new EntitySelector('@p');
    }
    static allPlayers() {
        return new EntitySelector('@a');
    }
    static allEntities() {
        return new EntitySelector('@e');
    }
    #variable;
    #arguments = [];
}
export class CustomSelector {
    selectorType;
    selector;
    constructor(selectorType, selector) {
        this.selectorType = selectorType;
        this.selector = selector;
    }
    buildSelector() {
        return this.selector;
    }
}
export var NumericDataType;
(function (NumericDataType) {
    NumericDataType["Byte"] = "byte";
    NumericDataType["Short"] = "short";
    NumericDataType["Int"] = "int";
    NumericDataType["Long"] = "long";
    NumericDataType["Float"] = "float";
    NumericDataType["Double"] = "double";
})(NumericDataType || (NumericDataType = {}));
export class NBTReference {
    target;
    path;
    constructor(config) {
        this.target = config.target;
        this.path = config.path;
    }
    assignScore(score, dataType, scale) {
        return new Execute().storeResult(new ExecuteStoreNBTDestination(this, dataType, scale)).run(score.getValue());
    }
    assignNBT(nbt) {
        return new CustomCommand(`data modify ${this.target.selectorType} ${this.target.buildSelector()} ${this.path} set from ${nbt.target.selectorType} ${nbt.target.buildSelector()} ${nbt.path}`);
    }
    getValue(scale) {
        return new CustomCommand(`data get ${this.target.selectorType} ${this.target.buildSelector()} ${this.path} ${scale}`);
    }
    setValueLiteral(value) {
        return new CustomCommand(`data modify ${this.target.selectorType} ${this.target.buildSelector()} ${this.path} set value ${value}`);
    }
}
export class ScoreReference {
    objective;
    target;
    constructor(objective, target) {
        this.objective = objective;
        this.target = target;
    }
    getValue() {
        return new CustomCommand(`scoreboard players get ${this.target.buildSelector()} ${this.objective}`);
    }
    addConstant(value) {
        return new CustomCommand(`scoreboard players add ${this.target.buildSelector()} ${this.objective} ${value}`);
    }
    subtractConstant(value) {
        return new CustomCommand(`scoreboard players remove ${this.target.buildSelector()} ${this.objective} ${value}`);
    }
    assignConstant(value) {
        if (!Number.isInteger(value)) {
            log.warn(`Cannot assign non-integer value ${value} to score ${this.objective}`);
        }
        return new CustomCommand(`scoreboard players set ${this.target.buildSelector()} ${this.objective} ${value}`);
    }
    opScore(operation, score) {
        return new CustomCommand(`scoreboard players operation ${this.target.buildSelector()} ${this.objective} ${operation} ${score.target.buildSelector()} ${score.objective}`);
    }
    addScore(score) {
        return this.opScore('+=', score);
    }
    subtractScore(score) {
        return this.opScore('-=', score);
    }
    assignScore(score) {
        return this.opScore('=', score);
    }
    multiplyScore(score) {
        return this.opScore('*=', score);
    }
    divideScore(score) {
        return this.opScore('/=', score);
    }
    moduloScore(score) {
        return this.opScore('%=', score);
    }
    greaterThan(other) {
        if (typeof other === 'number') {
            return new ScoreInRange(this, NumberRange.greaterThanOrEqualTo(other + 1));
        }
        return new CompareScores(this, '>', other);
    }
    lessThan(other) {
        if (typeof other === 'number') {
            return new ScoreInRange(this, NumberRange.lessThanOrEqualTo(other - 1));
        }
        return new CompareScores(this, '<', other);
    }
    equalTo(other) {
        if (typeof other === 'number') {
            return new ScoreInRange(this, NumberRange.exactly(other));
        }
        return new CompareScores(this, '=', other);
    }
    between(min, max) {
        return new ScoreInRange(this, NumberRange.between(min, max));
    }
    lessThanOrEqualTo(other) {
        if (typeof other === 'number') {
            return new ScoreInRange(this, NumberRange.lessThanOrEqualTo(other));
        }
        return new CompareScores(this, '<=', other);
    }
    greaterThanOrEqualTo(other) {
        if (typeof other === 'number') {
            return new ScoreInRange(this, NumberRange.greaterThanOrEqualTo(other));
        }
        return new CompareScores(this, '>=', other);
    }
    assignCommand(command) {
        return new Execute().storeResult(this).run(command);
    }
    buildExecuteStoreDestination() {
        return `score ${this.target.buildSelector()} ${this.objective}`;
    }
}
export class NumberRange {
    min;
    max;
    constructor(min, max) {
        this.min = min;
        this.max = max;
    }
    build() {
        if (this.min === this.max)
            return this.min.toString();
        if (this.min === undefined)
            return `..${this.max}`;
        if (this.max === undefined)
            return `${this.min}..`;
        return `${this.min}..${this.max}`;
    }
    static lessThanOrEqualTo(max) {
        return new NumberRange(undefined, max);
    }
    static greaterThanOrEqualTo(min) {
        return new NumberRange(min, undefined);
    }
    static between(min, max) {
        return new NumberRange(min, max);
    }
    static exactly(value) {
        return new NumberRange(value, value);
    }
}
export class Execute {
    subcommands;
    constructor(subcommands = []) {
        this.subcommands = subcommands;
    }
    append(subcommand) {
        this.subcommands.push(subcommand);
        return this;
    }
    as(target) {
        return this.append(new ExecuteCustomSubcommand("as " + target.buildSelector()));
    }
    at(target) {
        return this.append(new ExecuteCustomSubcommand("at " + target.buildSelector()));
    }
    if(condition) {
        return this.append(new ExecuteCustomSubcommand("if " + condition.buildExecuteCondition()));
    }
    unless(condition) {
        return this.append(new ExecuteCustomSubcommand("unless " + condition.buildExecuteCondition()));
    }
    storeResult(destination) {
        return this.append(new ExecuteCustomSubcommand("store result " + destination.buildExecuteStoreDestination()));
    }
    storeSuccess(destination) {
        return this.append(new ExecuteCustomSubcommand("store success " + destination.buildExecuteStoreDestination()));
    }
    run(command) {
        return this.append(new ExecuteCustomSubcommand("run " + command.buildCommand()));
    }
    buildCommand() {
        const subcommandString = this.subcommands.map(subcommand => subcommand.buildExecuteSubCommand()).join(' ');
        return `execute ${subcommandString}`;
    }
}
export class ExecuteCustomSubcommand {
    command;
    constructor(command) {
        this.command = command;
    }
    buildExecuteSubCommand() {
        return this.command;
    }
}
export class ExecuteStoreNBTDestination {
    target;
    dataType;
    scale;
    constructor(target, dataType, scale) {
        this.target = target;
        this.dataType = dataType;
        this.scale = scale;
    }
    buildExecuteStoreDestination() {
        return `${this.target.target.selectorType} ${this.target.target.buildSelector()} ${this.target.path} ${this.dataType} ${this.scale}`;
    }
}
export class CompareScores {
    lhs;
    operator;
    rhs;
    constructor(lhs, operator, rhs) {
        this.lhs = lhs;
        this.operator = operator;
        this.rhs = rhs;
    }
    buildExecuteCondition() {
        const lhs = this.lhs;
        const rhs = this.rhs;
        return `score ${lhs.target.buildSelector()} ${lhs.objective} ${this.operator} ${rhs.target.buildSelector()} ${rhs.objective}`;
    }
}
export class ScoreInRange {
    score;
    range;
    constructor(score, range) {
        this.score = score;
        this.range = range;
    }
    buildExecuteCondition() {
        return `score ${this.score.target.buildSelector()} ${this.score.objective} matches ${this.range.build()}`;
    }
}
export var Color;
(function (Color) {
    Color["Black"] = "black";
    Color["DarkBlue"] = "dark_blue";
    Color["DarkGreen"] = "dark_green";
    Color["DarkAqua"] = "dark_aqua";
    Color["DarkRed"] = "dark_red";
    Color["DarkPurple"] = "dark_purple";
    Color["Gold"] = "gold";
    Color["Gray"] = "gray";
    Color["DarkGray"] = "dark_gray";
    Color["Blue"] = "blue";
    Color["Green"] = "green";
    Color["Aqua"] = "aqua";
    Color["Red"] = "red";
    Color["LightPurple"] = "light_purple";
    Color["Yellow"] = "yellow";
    Color["White"] = "white";
})(Color || (Color = {}));
export class TextComponentClickEvent {
    action;
    value;
    constructor(action, value) {
        this.action = action;
        this.value = value;
    }
    openURL(url) {
        return new TextComponentClickEvent("open_url", url);
    }
    openFile(file) {
        return new TextComponentClickEvent("open_file", file);
    }
    runCommand(command) {
        return new TextComponentClickEvent("run_command", command);
    }
    suggestCommand(command) {
        return new TextComponentClickEvent("suggest_command", command);
    }
    changePage(page) {
        return new TextComponentClickEvent("change_page", page.toString());
    }
    copyToClipboard(text) {
        return new TextComponentClickEvent("copy_to_clipboard", text);
    }
}
export class TextComponent {
    /**
     * This text is appended to the end of the text.
     */
    extra;
    color;
    bold;
    italic;
    underlined;
    strikethrough;
    obfuscated;
    /**
     * When shift-clicking the text, this text will be inserted into the chat.
     */
    insertion;
    /**
     * When clicking the text, this action will be performed.
     */
    clickEvent;
    constructor(value) {
        Object.assign(this, value);
    }
    build() {
        return JSON.stringify(this);
    }
    append(children) {
        if (!this.extra)
            this.extra = [];
        this.extra.push(...children);
        return this;
    }
    static plainText(text) {
        return new TextComponent({ text });
    }
    static translatedText(key, options = {}) {
        return new TextComponent({
            translate: key,
            with: options.with
        });
    }
    static score(score, options = {}) {
        return new TextComponent({
            score: {
                name: score.target.buildSelector(),
                objective: score.objective,
                value: options.value
            }
        });
    }
    static entityNames(entity, options = {}) {
        return new TextComponent({
            selector: entity.buildSelector(),
            separator: options.separator
        });
    }
    static keybind(keybind) {
        return new TextComponent({ keybind });
    }
    static nbt(nbt, options = {}) {
        return new TextComponent({
            nbt: nbt.path,
            [nbt.target.selectorType]: nbt.target.buildSelector(),
            interpret: options.interpret,
            separator: options.separator
        });
    }
}
export class Tellraw {
    target;
    message;
    constructor(target, message) {
        this.target = target;
        this.message = message;
    }
    buildCommand() {
        return [`tellraw ${this.target.buildSelector()} ${this.message.build()}`];
    }
}
export class Tag {
    values;
    replace;
    constructor(values, replace = false) {
        this.values = values;
        this.replace = replace;
    }
    build() {
        return JSON.stringify({
            replace: this.replace,
            values: this.values.map(id => id.build())
        });
    }
}
export class Datapack {
    files = new Map();
    functions = new Map();
    onLoadFunctions;
    onTickFunctions;
    setPackMeta(packMeta) {
        this.files.set('pack.mcmeta', JSON.stringify(packMeta));
    }
    setFunction(namespacedId, commands) {
        if (this.functions.has(namespacedId)) {
            throw new Error(`Function ${namespacedId.build()} already exists`);
        }
        this.functions.set(namespacedId, []);
        const commandsResolved = Array.from(commands instanceof Function ? commands() : commands);
        this.functions.get(namespacedId).push(...commandsResolved);
        return new FunctionReference(namespacedId);
    }
    build() {
        for (const [namespacedId, commands] of this.functions) {
            const path = `data/${namespacedId.namespace}/functions/${namespacedId.id}.mcfunction`;
            this.files.set(path, commands.flat().map(command => command.buildCommand()).join('\n'));
        }
        if (this.onLoadFunctions) {
            this.files.set('data/minecraft/tags/functions/load.json', this.onLoadFunctions.build());
        }
        if (this.onTickFunctions) {
            this.files.set('data/minecraft/tags/functions/tick.json', this.onTickFunctions.build());
        }
        return this.files;
    }
}
export class FunctionAllocator {
    datapack;
    namespace;
    constructor(options) {
        this.datapack = options.datapack;
        this.namespace = options.namespace;
    }
    function(commands) {
        const name = commands instanceof Function ? commands.name || 'untitled' : 'untitled';
        const id = this.#idFromString(name);
        return this.datapack.setFunction(id, commands);
    }
    addOnLoadFunction(commands) {
        const fun = this.function(commands);
        if (!this.datapack.onLoadFunctions) {
            this.datapack.onLoadFunctions = new Tag([]);
        }
        this.datapack.onLoadFunctions.values.push(fun.namespacedId);
        return fun;
    }
    addOnTickFunction(commands) {
        const fun = this.function(commands);
        if (!this.datapack.onTickFunctions) {
            this.datapack.onTickFunctions = new Tag([]);
        }
        this.datapack.onTickFunctions.values.push(fun.namespacedId);
        return fun;
    }
    #idFromString(name) {
        const cleanedName = name.replace(/([a-z])([A-Z])/g, '$1_$2').toLowerCase();
        let id;
        let i = 0;
        do {
            id = this.#id(`${cleanedName}${i === 0 ? '' : i}`);
            i++;
        } while (this.datapack.functions.has(id));
        return id;
    }
    #id(id) {
        if (this.namespace instanceof Namespace) {
            return this.namespace.id(id);
        }
        else {
            return this.namespace.childID(id);
        }
    }
}
