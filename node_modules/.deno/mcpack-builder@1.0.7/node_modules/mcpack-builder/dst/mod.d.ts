export interface Logger {
    log(message: string): void;
    warn(message: string): void;
    error(message: string): void;
}
export declare function setLogger(logger: Logger): void;
export declare class Namespace {
    namespace: string;
    constructor(namespace: string);
    id(id: string): NamespacedID;
    static validate(namespace: string): string[];
}
export declare class NamespacedID {
    namespace: string;
    id: string;
    constructor(namespace: string, id: string);
    childID(id: string): NamespacedID;
    build(): string;
    toFunction(): FunctionReference;
    static fromString(namespacedId: string): NamespacedID;
    static validate(namespacedId: string): string[];
}
export declare class Duration {
    value: number;
    unit: string;
    constructor(value: number, unit: string);
    build(): string;
    multiply(factor: number): Duration;
    toTicks(): number;
    add(other: Duration): Duration;
    static ticks(value: number): Duration;
    static seconds(value: number): Duration;
    static days(value: number): Duration;
}
export declare enum ScheduleMode {
    Append = "append",
    Replace = "replace"
}
export declare class FunctionReference {
    #private;
    namespacedId: NamespacedID | TagReference;
    constructor(namespacedId: NamespacedID | TagReference);
    run(): CustomCommand;
    schedule(delay: Duration, mode?: ScheduleMode): CustomCommand;
    scheduleClear(): CustomCommand;
}
export declare class TagReference {
    namespacedId: NamespacedID;
    constructor(namespacedId: NamespacedID);
    build(): string;
}
export interface Command {
    buildCommand(): string;
}
export declare class CustomCommand implements Command {
    command: string;
    constructor(command: string);
    buildCommand(): string;
}
export declare class ScoreAllocator {
    #private;
    scoreboard: Scoreboard;
    prefix: string;
    constantPrefix: string;
    initConstants: Command[];
    constants: Set<number>;
    constructor(config: {
        scoreboard: Scoreboard;
        prefix?: string;
        constantPrefix?: string;
    });
    score(): ScoreReference;
    constant(value: number): ScoreReference;
}
export declare class Comment implements Command {
    comment: string;
    constructor(comment: string);
    buildCommand(): string;
}
export declare class Scoreboard {
    objective: string;
    criteria: string;
    displayName?: TextComponent;
    constructor(options: {
        objective: string;
        criteria?: string;
        displayName?: TextComponent;
    });
    create(): CustomCommand;
    remove(): CustomCommand;
    entity(target: CustomSelector | EntitySelector): ScoreReference;
    custom(player: string): ScoreReference;
    static verifyObjective(objective: string): "Objective name must be 16 characters or less" | "Objective name must only contain letters, numbers, and underscores" | undefined;
}
export interface TargetSelector {
    selectorType: string;
    buildSelector(): string;
}
export declare class EntitySelector implements TargetSelector {
    #private;
    selectorType: string;
    constructor(variable: string);
    buildSelector(): string;
    limit(count: number): this;
    hasScoreboardTag(tag: string): this;
    noScoreboardTag(tag: string): this;
    sortNearest(): this;
    sortFurthest(): this;
    sortRandom(): this;
    sortArbitrary(): this;
    static self(): EntitySelector;
    static nearestPlayer(): EntitySelector;
    static allPlayers(): EntitySelector;
    static allEntities(): EntitySelector;
}
export declare class CustomSelector implements TargetSelector {
    selectorType: string;
    selector: string;
    constructor(selectorType: string, selector: string);
    buildSelector(): string;
}
export declare enum NumericDataType {
    Byte = "byte",
    Short = "short",
    Int = "int",
    Long = "long",
    Float = "float",
    Double = "double"
}
export declare class NBTReference {
    target: TargetSelector;
    path: string;
    constructor(config: {
        target: TargetSelector;
        path: string;
    });
    assignScore(score: ScoreReference, dataType: NumericDataType, scale: number): Execute;
    assignNBT(nbt: NBTReference): CustomCommand;
    getValue(scale: number): CustomCommand;
    setValueLiteral(value: string): CustomCommand;
}
export declare class ScoreReference implements ExecuteStoreDestination {
    objective: string;
    target: EntitySelector | CustomSelector;
    constructor(objective: string, target: EntitySelector | CustomSelector);
    getValue(): CustomCommand;
    addConstant(value: number): CustomCommand;
    subtractConstant(value: number): CustomCommand;
    assignConstant(value: number): CustomCommand;
    opScore(operation: string, score: ScoreReference): CustomCommand;
    addScore(score: ScoreReference): CustomCommand;
    subtractScore(score: ScoreReference): CustomCommand;
    assignScore(score: ScoreReference): CustomCommand;
    multiplyScore(score: ScoreReference): CustomCommand;
    divideScore(score: ScoreReference): CustomCommand;
    moduloScore(score: ScoreReference): CustomCommand;
    greaterThan(other: ScoreReference | number): ScoreInRange | CompareScores;
    lessThan(other: ScoreReference | number): ScoreInRange | CompareScores;
    equalTo(other: ScoreReference | number): ScoreInRange | CompareScores;
    between(min: number, max: number): ScoreInRange;
    lessThanOrEqualTo(other: ScoreReference | number): ScoreInRange | CompareScores;
    greaterThanOrEqualTo(other: ScoreReference | number): ScoreInRange | CompareScores;
    assignCommand(command: Command): Execute;
    buildExecuteStoreDestination(): string;
}
export declare class NumberRange {
    min: number | undefined;
    max: number | undefined;
    private constructor();
    build(): string;
    static lessThanOrEqualTo(max: number): NumberRange;
    static greaterThanOrEqualTo(min: number): NumberRange;
    static between(min: number, max: number): NumberRange;
    static exactly(value: number): NumberRange;
}
export declare class Execute implements Command {
    subcommands: ExecuteSubCommand[];
    constructor(subcommands?: ExecuteSubCommand[]);
    append(subcommand: ExecuteSubCommand): this;
    as(target: EntitySelector | CustomSelector): this;
    at(target: EntitySelector | CustomSelector): this;
    if(condition: ExecuteCondition): this;
    unless(condition: ExecuteCondition): this;
    storeResult(destination: ExecuteStoreDestination): this;
    storeSuccess(destination: ExecuteStoreDestination): this;
    run(command: Command): this;
    buildCommand(): string;
}
export interface ExecuteSubCommand {
    buildExecuteSubCommand(): string;
}
export interface ExecuteStoreDestination {
    buildExecuteStoreDestination(): string;
}
export interface ExecuteCondition {
    buildExecuteCondition(): string;
}
export declare class ExecuteCustomSubcommand implements ExecuteSubCommand {
    command: string;
    constructor(command: string);
    buildExecuteSubCommand(): string;
}
export declare class ExecuteStoreNBTDestination {
    target: NBTReference;
    dataType: NumericDataType;
    scale: number;
    constructor(target: NBTReference, dataType: NumericDataType, scale: number);
    buildExecuteStoreDestination(): string;
}
export type CompareScoreOperator = '<' | '<=' | '=' | '>=' | '>';
export declare class CompareScores implements ExecuteCondition {
    lhs: ScoreReference;
    operator: CompareScoreOperator;
    rhs: ScoreReference;
    constructor(lhs: ScoreReference, operator: CompareScoreOperator, rhs: ScoreReference);
    buildExecuteCondition(): string;
}
export declare class ScoreInRange implements ExecuteCondition {
    score: ScoreReference;
    range: NumberRange;
    constructor(score: ScoreReference, range: NumberRange);
    buildExecuteCondition(): string;
}
export declare enum Color {
    Black = "black",
    DarkBlue = "dark_blue",
    DarkGreen = "dark_green",
    DarkAqua = "dark_aqua",
    DarkRed = "dark_red",
    DarkPurple = "dark_purple",
    Gold = "gold",
    Gray = "gray",
    DarkGray = "dark_gray",
    Blue = "blue",
    Green = "green",
    Aqua = "aqua",
    Red = "red",
    LightPurple = "light_purple",
    Yellow = "yellow",
    White = "white"
}
export declare class TextComponentClickEvent {
    action: string;
    value: string;
    constructor(action: string, value: string);
    openURL(url: string): TextComponentClickEvent;
    openFile(file: string): TextComponentClickEvent;
    runCommand(command: string): TextComponentClickEvent;
    suggestCommand(command: string): TextComponentClickEvent;
    changePage(page: number): TextComponentClickEvent;
    copyToClipboard(text: string): TextComponentClickEvent;
}
export declare class TextComponent {
    [key: string]: unknown;
    /**
     * This text is appended to the end of the text.
     */
    extra?: TextComponent[];
    color?: Color;
    bold?: boolean;
    italic?: boolean;
    underlined?: boolean;
    strikethrough?: boolean;
    obfuscated?: boolean;
    /**
     * When shift-clicking the text, this text will be inserted into the chat.
     */
    insertion?: string;
    /**
     * When clicking the text, this action will be performed.
     */
    clickEvent?: TextComponentClickEvent;
    constructor(value: unknown);
    build(): string;
    append(children: TextComponent[]): this;
    static plainText(text: string): TextComponent;
    static translatedText(key: string, options?: {
        with?: TextComponent[];
    }): TextComponent;
    static score(score: ScoreReference, options?: {
        value?: string;
    }): TextComponent;
    static entityNames(entity: EntitySelector | CustomSelector, options?: {
        separator?: TextComponent;
    }): TextComponent;
    static keybind(keybind: string): TextComponent;
    static nbt(nbt: NBTReference, options?: {
        interpret?: boolean;
        separator?: TextComponent;
    }): TextComponent;
}
export declare class Tellraw {
    target: EntitySelector | CustomSelector;
    message: TextComponent;
    constructor(target: EntitySelector | CustomSelector, message: TextComponent);
    buildCommand(): string[];
}
export declare class Tag {
    values: (NamespacedID | TagReference)[];
    replace: boolean;
    constructor(values: (NamespacedID | TagReference)[], replace?: boolean);
    build(): string;
}
export type DatapackFunctionProvider = Iterable<Command | Command[]> | (() => Iterable<Command | Command[]>);
export declare class Datapack {
    files: Map<string, string>;
    functions: Map<NamespacedID, (Command | Command[])[]>;
    onLoadFunctions?: Tag;
    onTickFunctions?: Tag;
    setPackMeta(packMeta: PackMeta): void;
    setFunction(namespacedId: NamespacedID, commands: DatapackFunctionProvider): FunctionReference;
    build(): Map<string, string>;
}
export interface PackMeta {
    pack: {
        pack_format: number;
        description: string;
    };
}
export declare class FunctionAllocator {
    #private;
    readonly datapack: Datapack;
    readonly namespace: Namespace | NamespacedID;
    constructor(options: {
        datapack: Datapack;
        namespace: NamespacedID | Namespace;
    });
    function(commands: DatapackFunctionProvider): FunctionReference;
    addOnLoadFunction(commands: DatapackFunctionProvider): FunctionReference;
    addOnTickFunction(commands: DatapackFunctionProvider): FunctionReference;
}
